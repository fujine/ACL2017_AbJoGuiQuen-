 	
package model.entites;

import model.Jeu;
import model.entites.Hero;
import model.entites.Monstre;
import model.plateau.Plateau;
//import monJeu.Entite;
//import moteurJeu.Commande;

import java.awt.*;
import java.util.ArrayList;
import java.util.Random;

public class Chevalier<dep> extends Monstre {
    Hero h = new Hero(coord, plateau);
    int m;
    
 // Jeu mod = Jeu.getInstance();
    




    /**
     * Constructeur Ã  partir d'une position et d'un plateau avec dÃ©finition de la vie du chevalier
     * @param coord CoordonnÃ©e du Chevalier sur le plateau
     * @param plateau Plateau au qu'elle appartient le Chevalier
     */
    public Chevalier(Point coord, Plateau plateau) {
        super(coord, plateau);
        vie = 1;
        degat = 1;
        dir = Direction.BAS;
    }
    
    //verifier deplacement chevalier
/*
    private boolean estAccessible (Point p) {
    	
    	 if(plateau.estLibre(p.x,p.y) && mod.collisionEntites(this,new Point(p.x,p.y)) == null)
	            if (p.x >= 0 && p.y>= 0 && p.x < mod.getPlateau().getLargeur() && p.y < mod.getPlateau().getHauteur())
	                return true;
		return false;
    }
    */
   
    public int distance(Point p1, Point p2) {
        //p1=h.coord;
        //p2=this.coord;
        return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
    }

    //calculer le minimum des distances

    private int minDis(int a, int b, int c, int d) {
    	if(a<=b && a<=c && a<=d) return 0;
    	else if(b<=a && b<=c && b<=d) return 1;
    	else if(c<=a && c<=b && c<=d) return 2;
    	else return 3;
        	
        	
       
    }

    
    /**
     * Calcul et vÃ©rifie le dÃ©placement du chevalier avant de la deplacer
     */
    @Override

    // dï¿½placement intelligent 
    
    
  
    /*
    public void deplacer() {
    	
    	
    	int posX=coord.x;
    	int posY=coord.y;
    	

    	 ArrayList<Point> CaseAc = new ArrayList<>();
    	 CaseAc.add(new Point(1,0));
    	 CaseAc.add(new Point(-1,0));
    	 CaseAc.add(new Point(0,1));
    	 CaseAc.add(new Point(0,-1));
    	
    	for(Point m: CaseAc) {
    		if(!plateau.estLibre(posX+m.x,posY+m.y))
    			CaseAc.remove(m);
    	}
  
    	Point min = minDis(CaseAc,posX,posY);
    	this.coord.move(posX+min.x, posY+min.y);
    
    }
    */
   

    
    public void deplacer() {
    	int posX = getCoord().x;
        int posY = getCoord().y;
    	//calculer les 4 distance possible
       int dis1= distance(h.getCoord(),new Point(posX+1,posY));
       int dis2 = distance(h.getCoord(),new Point(posX,posY+1));
       int dis3=distance(h.getCoord(),new Point(posX-1,posY));
       int dis4 = distance(h.getCoord(),new Point(posX,posY-1));

       m=minDis(dis1,dis2,dis3,dis4);

  Jeu mod = Jeu.getInstance();
        //Random r = new Random();
       
        

        switch (m) {
            //Haut
            case 0 :
                posX++;
               if( plateau.estLibre(posX++,posY)) 
                dir = Direction.DROITE;
               m=minDis(9999,dis2,dis3,dis4);
                break;
                //Bas
            case 1: 
            	posY++;
            	 if( plateau.estLibre(posX,posY++)) 
                dir = Direction.BAS;
            	 m=minDis(dis1,9999,dis3,dis4);
                break;
                //Gauche
            case 2:
                posX--;
                if( plateau.estLibre(posX--,posY))
                dir = Direction.GAUCHE;
                m=minDis(dis1,dis2,9999,dis4);
                break;
            case 3 : case 5:
                posY--;
                if( plateau.estLibre(posX,posY--))
                dir = Direction.HAUT;
                m=minDis(dis1,dis2,dis3,9999);
                break;
		
    }
        if (mod.collisionEntites(this,new Point(posX,posY)) != null && mod.collisionEntites(this,new Point(posX,posY)).getType().equals("h")){
            mod.appliquerDegats(this.getDegat());
        }
	
	 if( mod.collisionEntites(this,new Point(getCoord().x,getCoord().y)) == null)
            if (posX >= 0 && posY>= 0 && posX < mod.getPlateau().getLargeur() && posY < mod.getPlateau().getHauteur())
                coord.move(posX,posY);

}
}





////////////////////////////////////////////////////////////////////
         /*
            if(m==dis1 && plateau.estLibre(h.getCoord().x+1,h.getCoord().y) ) setCoord(new Point(getCoord().x+1,getCoord().y));
            else if(m==dis2 && plateau.estLibre(h.getCoord().x-1,h.getCoord().y)) setCoord(new Point(getCoord().x-1,getCoord().y));
            else if(m==dis3 && plateau.estLibre(h.getCoord().x,h.getCoord().y+1)) setCoord(new Point(getCoord().x,getCoord().y+1));
            else if(m==dis3 && plateau.estLibre(h.getCoord().x,h.getCoord().y-1))setCoord(new Point(getCoord().x+1,getCoord().y-1)); 
            else 
            	*/



///////////////////////////////////////////////
    	/*

        Jeu mod = Jeu.getInstance();
        Random r = new Random();
        int dep = r.nextInt(6);
        int posX = getCoord().x;
        int posY = getCoord().y;

        switch (dep) {
            //Haut
            case 0 :
                posY--;
                dir = Direction.HAUT;
                break;
                //Bas
            case 1: case 4:
                dir = Direction.BAS;
                posY++;
                break;
                //Gauche
            case 2:
                posX--;
                dir = Direction.GAUCHE;
                break;
            case 3 : case 5:
                posX++;
                dir = Direction.DROITE;
                break;
        }


*/
		/*
        if (mod.collisionEntites(this,new Point(posX,posY)) != null && mod.collisionEntites(this,new Point(posX,posY)).getType().equals("h")){
            mod.appliquerDegats(this.getDegat());
        }
*/
       
		
		//Vérification de la case du plateau si elle est libre et vérifie la collision avec d'autres entités
		/*
        if(plateau.estLibre(posX,posY) && mod.collisionEntites(this,new Point(posX,posY)) == null)
            if (posX >= 0 && posY>= 0 && posX < mod.getPlateau().getLargeur() && posY < mod.getPlateau().getHauteur())
                coord.move(posX,posY);
    }
    ===================================================================================
     //	setCoord(new Point(getCoord().x+1,getCoord().y));
    	
    	
    	/*
    	
    	
    	
    	//Commande c = new Commande();
		int deplacement=-1;
		
		Jeu mod = Jeu.getInstance();
		if (posX < h.coord.x+3 && posX > h.coord.x-3 && posY < h.coord.y+3 && posY > h.coord.y -3){
			if(posX >= h.coord.x && posY >= h.coord.y){
				if (posX-h.coord.x >= posY-h.coord.y)deplacement = 1; //gauche
				else deplacement = 0;//haut
			}
			if (posX >= h.coord.x && posY < h.coord.y){
				if (posX-h.coord.x > h.coord.y-posY)deplacement = 1;
				else deplacement = 2;//bas
			}
			if (posX < h.coord.x && posY >= h.coord.y){
				if (h.coord.x-posX > posY-h.coord.y)deplacement = 3;//droit
				else deplacement = 0;
			}
			if (posX < h.coord.x && posY < h.coord.y){
				if (h.coord.x-posX > h.coord.y-posY)deplacement = 3;
				else deplacement = 2;
			}
		}
		else{
			deplacement = (int)(Math.random()*6);
		}
		switch (deplacement){
		case 1:
			posX--;
            dir = Direction.GAUCHE;
			break;
		case 0 :
            posY--;
            dir = Direction.HAUT;
			break;
		case 2: case 4:
            dir = Direction.BAS;
            posY++;
			break;
		case 3: case 5:
            dir = Direction.DROITE;
            posY++;
			break;
		}
	
    	
    	*/
    	
        //Random r = new Random();


       // int posX = this.getCoord().x;
        //int posY = this.getCoord().y;


////////////////////////////////////////////////



 private Point minDis(ArrayList<Point> a, int posX, int posY) {
    	Point min = a.get(0);
    	int minDist = distance(h.coord, new Point(posX+min.x, posY+min.y));
    	a.remove(0);
        for(Point m: a) {
        	int d=distance(h.coord, new Point(posX+m.x, posY+m.y));
        	
        	if(d<minDist) {
        		minDist=d;
        		min=m;
        	}
        	
        	
        }
         return min;
    }

/////////////////////////////////////////////////////


/*
        //calculer les 4 distance possible
         dis1= distance(h.getCoord(),new Point(getCoord().x+1,getCoord().y));
         dis4 = distance(h.getCoord(),new Point(getCoord().x,getCoord().y+1));
         dis2=distance(h.getCoord(),new Point(getCoord().x-1,getCoord().y));
         dis3 = distance(h.getCoord(),new Point(getCoord().x,getCoord().y-1));

        Jeu mod = Jeu.getInstance();

        //choisir le minimum des 4 distnces par rapport ï¿½ la position de l'hero
        m=MinDis(dis1,dis2,dis3,dis4);

      /*  
        if(m==1 && plateau.estLibre(h.getCoord().x+1,h.getCoord().y) ) {
        	setCoord(new Point(getCoord().x+1,getCoord().y));
        	
        }
        else if(m==2 && plateau.estLibre(h.getCoord().x-1,h.getCoord().y)) setCoord(new Point(getCoord().x-1,getCoord().y));
        else if(m==3 && plateau.estLibre(h.getCoord().x,h.getCoord().y+1)) setCoord(new Point(getCoord().x,getCoord().y+1));
        else setCoord(new Point(getCoord().x+1,getCoord().y-1)); 
     */
    	/*
           	
    		switch(m) {
    		//aller vers la
    		case 1:  getCoord().x+1; 
    		 // m=MinDis(99999,dis2,dis3,dis4);
    		break;
    		//aller vers la gauche
    		case 2: /*if( plateau.estLibre(h.getCoord().x-1,h.getCoord().y) )*/ setCoord(new Point(getCoord().x-1,getCoord().y));
    		//else m=MinDis(dis1,99999,dis3,dis4);
    		break;
    		//aller vers le haut
    		case 3:/* if( plateau.estLibre(h.getCoord().x,h.getCoord().y-1) )*/ setCoord(new Point(getCoord().x,getCoord().y+1));
    		//else m=MinDis(dis1,dis2,99999,dis4); break;
    		//aller vers le bas
    		case 4: /* if( plateau.estLibre(h.getCoord().x,h.getCoord().y+1) ) */setCoord(new Point(getCoord().x,getCoord().y-1));
    		//else m=MinDis(dis1,dis2,dis3,99999);
    		break;
    		
    		}
    		
    		
    		 if (mod.collisionEntites(this,new Point(getCoord().x,getCoord().y)) != null && mod.collisionEntites(this,new Point(getCoord().x,getCoord().y)).getType().equals("h")){
    	            mod.appliquerDegats(this.getDegat());
    	        }
    		
    		 if(plateau.estLibre(getCoord().x,getCoord().y) && mod.collisionEntites(this,new Point(getCoord().x,getCoord().y)) == null)
    	            if (getCoord().x >= 0 && getCoord().y>= 0 && getCoord().x < mod.getPlateau().getLargeur() && getCoord().y < mod.getPlateau().getHauteur())
    	                coord.move(getCoord().x,getCoord().y);